{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":""},{"location":"#continuous-collision-detection","title":"Continuous Collision Detection","text":"<p>Welcome! This is the website for the Continuous Collision Detection (CCD) projects started at the Geometric Computing Lab @ NYU. The goal of this work is to provide provably correct and efficient algorithms for continuous collision detection and to provide large-scale benchmarks for evaluating the correctness and efficiency of future developments.</p> <p>We have three papers on this topic, and the code for the algorithms and the benchmarks are available on GitHub. Below you can find the abstracts for the papers, links to the papers, and links to the code repositories.</p>"},{"location":"#papers","title":"Papers","text":""},{"location":"#a-large-scale-benchmark-and-an-inclusion-based-algorithm-for-continuous-collision-detection","title":"A Large Scale Benchmark and an Inclusion-Based Algorithm for Continuous Collision Detection","text":"<p>Bolun\u00a0Wang*, Zachary\u00a0Ferguson*, Teseo\u00a0Schneider, Xin\u00a0Jiang, Marco\u00a0Attene, Daniele\u00a0Panozzo (*Joint first authors)</p> <p>ACM Transactions on Graphics, 2021</p>"},{"location":"#abstract","title":"Abstract","text":"<p>We introduce a large-scale benchmark for continuous collision detection (CCD) algorithms, composed of queries manually constructed to highlight challenging degenerate cases and automatically generated using existing simulators to cover common cases. We use the benchmark to evaluate the accuracy, correctness, and efficiency of state-of-the-art continuous collision detection algorithms, both with and without minimal separation.</p> <p>We discover that, despite the widespread use of CCD algorithms, existing algorithms are either: (1) correct but impractically slow, (2) efficient but incorrect, introducing false negatives which will lead to interpenetration, or (3) correct but over conservative, reporting a large number of false positives which might lead to inaccuracies when integrated into a simulator.</p> <p>By combining the seminal interval root-finding algorithm introduced by Snyder in 1992 with modern predicate design techniques, we propose a simple and efficient CCD algorithm. This algorithm is competitive with state-of-the-art methods in terms of runtime while conservatively reporting the time of impact and allowing an explicit trade-off between runtime efficiency and the number of false positives reported.</p>"},{"location":"#fast-and-exact-root-parity-for-continuous-collision-detection","title":"Fast and Exact Root Parity for Continuous Collision Detection","text":"<p>Bolun\u00a0Wang, Zachary\u00a0Ferguson, Xin\u00a0Jiang, Marco \u00a0Attene, Daniele\u00a0Panozzo, Teseo\u00a0Schneider</p> <p>Computer Graphics Forum (Eurographics), 2022</p>"},{"location":"#abstract_1","title":"Abstract","text":"<p>We introduce the first exact root parity counter for continuous collision detection (CCD). That is, our algorithm computes the parity (even or odd) of the number of roots of the cubic polynomial arising from a CCD query. We note that the parity is unable to differentiate between zero (no collisions) and the rare case of two roots (collisions).</p> <p>Our method does not have numerical parameters to tune, has a performance comparable to efficient approximate algorithms, and is exact. We test our approach on a large collection of synthetic tests and real simulations, and we demonstrate that it can be easily integrated into existing simulators.</p>"},{"location":"#time-of-impact-dataset-for-continuous-collision-detection-and-a-scalable-conservative-algorithm","title":"Time of Impact Dataset for Continuous Collision Detection and a Scalable Conservative Algorithm","text":"<p>David\u00a0Belgrod, Bolun\u00a0Wang, Zachary\u00a0Ferguson, Xin\u00a0Zhao, Marco\u00a0Attene, Daniele\u00a0Panozzo, Teseo\u00a0Schneider</p> <p>In submission</p>"},{"location":"#abstract_2","title":"Abstract","text":"<p>We introduce a large-scale benchmark for broad- and narrow-phase continuous collision detection (CCD) over linearized trajectories with exact time of impacts and use it to evaluate the accuracy, correctness, and efficiency of 13 state-of-the-art CCD algorithms. Our analysis shows that several methods exhibit problems either in efficiency or accuracy.</p> <p>To overcome these limitations, we introduce an algorithm for CCD designed to be scalable on modern parallel architectures and provably correct when implemented using floating point arithmetic. We integrate our algorithm within the Incremental Potential Contact solver [Li et al. 2020] and evaluate its impact on various simulation scenarios. Our approach includes a broad-phase CCD to quickly filter out primitives having disjoint bounding boxes and a narrow-phase CCD that establishes whether the remaining primitive pairs indeed collide. Our broad-phase algorithm is efficient and scalable thanks to the experimental observation that sweeping along a coordinate axis performs surprisingly well on modern parallel architectures. For narrow-phase CCD, we re-design the recently proposed interval-based algorithm of Wang et al. [Wang et al. 2021] to work on massively parallel hardware.</p> <p>To foster the adoption and development of future linear CCD algorithms, and to evaluate their correctness, scalability, and overall performance, we release the dataset with analytic ground truth, the implementation of all the algorithms tested, and our testing framework.</p>"},{"location":"#code","title":"Code","text":"<ul> <li>GitHub Organization</li> <li>Wrapper and Benchmark</li> <li>Tight Inclusion CCD</li> <li>Exact Root Parity CCD</li> <li>Scalable CCD</li> <li>Symbolic CCD</li> <li>Queries:<ul> <li>Sample</li> <li>Full Dataset</li> <li>Sample Broad Phase</li> </ul> </li> </ul>"},{"location":"#data","title":"Data","text":"<p>All the data used in the papers is available on the NYU Faculty Digital Archive.</p> <p>This includes the handcrafted queries, simulation queries, rounded queries, and full scene and time of impact dataset.</p>"},{"location":"#acknowledgments","title":"Acknowledgments","text":"<p>We thank the NYU IT High Performance Computing for resources, services, and staff expertise.</p> <p>This work was partially supported by the NSF CAREER award under Grant No. 1652515; the NSF grants OAC-1835712, OIA-1937043, CHS-1908767, and CHS-1901091; National Key Research and Development Program of China No. 2020YFA0713700; Natural Science Foundation of China Grants No. 12171023 and 12001028; NSERC DGECR-2021-00461 and RGPIN-2021-03707; KAUST baseline funding (grant BAS/1/1679-01-01); EU ERC Advanced Grant CHANGE No. 694515 and EU project DIGITbrain/ProMED (952071); a Sloan Fellowship; a gift from Adobe Research; a gift from nTopology; and a gift from Advanced Micro Devices, Inc.</p>"},{"location":"root_parity/","title":"Root Parity","text":"<p> Fast and Exact Root Parity for Continuous Collision Detection Bolun Wang, Zachary Ferguson, Xin Jiang, Marco Attene, Daniele Panozzo, Teseo Schneider <p>Computer Graphics Forum (Eurographics), 2022 </p>          The parity of the roots between a moving triangle and a point (left) and between two moving edges (right), can be computed by counting the parity of the intersections of a ray (red) casted from the origin (red sphere) with the surface of a prism for the vertex-triangle case (left) or a cube for the edge-edge case (right)."},{"location":"root_parity/#paper","title":"Paper","text":"<p> Paper (PDF) Low res (PDF) </p>"},{"location":"root_parity/#abstract","title":"Abstract","text":"<p>We introduce the first exact root parity counter for continuous collision detection (CCD). That is, our algorithm computes the parity (even or odd) of the number of roots of the cubic polynomial arising from a CCD query. We note that the parity is unable to differentiate between zero (no collisions) and the rare case of two roots (collisions).</p> <p>Our method does not have numerical parameters to tune, has a performance comparable to efficient approximate algorithms, and is exact. We test our approach on a large collection of synthetic tests and real simulations, and we demonstrate that it can be easily integrated into existing simulators.</p>"},{"location":"root_parity/#fast-forward","title":"Fast Forward","text":""},{"location":"root_parity/#presentation","title":"Presentation","text":"<ul> <li>Watch our full Eurographics 2022 presentation on Bilibili (English)!</li> </ul>"},{"location":"root_parity/#simulation-videos","title":"Simulation Videos","text":"Your browser does not support the video tag.               We drop three elastic Octocats into a bowl and use our CCD within a filtered line search to keep the meshes intersection-free (simulated using IPC [Li et al. 2020] with a timestep of 0.07s).               Your browser does not support the video tag.               We run the mat-twist experiment from [Li et al. 2020] using our CCD method in the filtered line-search and timestep of 0.04 s. The mat is 1m \u00d7 1m \u00d7 8mm and our algorithm conservatively shifts the world by [11.75, 11.75, 12.24] which results in a rounding error of 2.66e-15."},{"location":"root_parity/#source-code-and-data","title":"Source Code and Data","text":"<ul> <li>Code</li> <li>Dataset of Rounded CCD Queries</li> </ul>"},{"location":"root_parity/#bibtex","title":"BibTex","text":"<pre><code>@article{Wang:2022:FastRootParity,\ntitle        = {Fast and Exact Root Parity for Continuous Collision Detection},\nauthor       = {Bolun Wang and Zachary Ferguson and Xin Jiang and Marco Attene and Daniele Panozzo and Teseo Schneider},\nyear         = 2022,\njournal      = {Computer Graphics Forum (Proceedings of Eurographics)},\nvolume       = 41,\nnumber       = 2,\nnumpages     = 9\n}\n</code></pre>"},{"location":"root_parity/#acknowledgments","title":"Acknowledgments","text":"<p>We thank the NYU IT High Performance Computing for resources, services, and staff expertise. This work was partially supported by the NSF CAREER award under Grant No. 1652515, the NSF grants OAC-1835712, OIA-1937043, CHS-1908767, CHS-1901091, National Key Research &amp; Development Program of China Grant No. 2020YFA0713701, Natural Science Foundation of China Grants No.~12171023 &amp; No. 12001028, NSERC DGECR-2021-00461 and RGPIN-2021-03707, EU ERC Advanced Grant CHANGE No. 694515, a Sloan Fellowship, a gift from Adobe Research, a gift from nTopology, and a gift from Advanced Micro Devices, Inc.</p>"},{"location":"scalable_ccd/","title":"Scalable CCD","text":"<p> Time of Impact Dataset for Continuous Collision Detection and a Scalable Conservative Algorithm David\u00a0Belgrod, Bolun\u00a0Wang, Zachary\u00a0Ferguson, Xin\u00a0Zhao, Marco\u00a0Attene, Daniele\u00a0Panozzo, Teseo\u00a0Schneider <p>In submission </p>          Approximate collision detection can lead to poor simulation results. We simulate this scene using Incremental Potential Contact [Li et al. 2020] which provides an intersection-free guarantee, but approximate collision detection (either broad- or narrow-phase) can break this guarantee. Here we see using an approximate broad-phase method (sweep and prune) results in missed collisions and intersections (see inset). In contrast, a conservative or exact method allows the ball to squeeze through the rollers and come out the bottom."},{"location":"scalable_ccd/#paper","title":"Paper","text":"<p> <p>arXiv </p>"},{"location":"scalable_ccd/#abstract","title":"Abstract","text":"<p>We introduce a large-scale benchmark for broad- and narrow-phase continuous collision detection (CCD) over linearized trajectories with exact time of impacts and use it to evaluate the accuracy, correctness, and efficiency of 13 state-of-the-art CCD algorithms. Our analysis shows that several methods exhibit problems either in efficiency or accuracy.</p> <p>To overcome these limitations, we introduce an algorithm for CCD designed to be scalable on modern parallel architectures and provably correct when implemented using floating point arithmetic. We integrate our algorithm within the Incremental Potential Contact solver [Li et al. 2020] and evaluate its impact on various simulation scenarios. Our approach includes a broad-phase CCD to quickly filter out primitives having disjoint bounding boxes and a narrow-phase CCD that establishes whether the remaining primitive pairs indeed collide. Our broad-phase algorithm is efficient and scalable thanks to the experimental observation that sweeping along a coordinate axis performs surprisingly well on modern parallel architectures. For narrow-phase CCD, we re-design the recently proposed interval-based algorithm of Wang et al. [Wang et al. 2021] to work on massively parallel hardware.</p> <p>To foster the adoption and development of future linear CCD algorithms, and to evaluate their correctness, scalability, and overall performance, we release the dataset with analytic ground truth, the implementation of all the algorithms tested, and our testing framework.</p>"},{"location":"scalable_ccd/#video","title":"Video","text":""},{"location":"scalable_ccd/#source-code-and-data","title":"Source Code and Data","text":"<ul> <li>Our Scalable CCD</li> <li>Algorithms and Testing Framework (coming soon!)</li> <li>Data:<ul> <li>Sample</li> <li>Full Dataset</li> </ul> </li> </ul>"},{"location":"scalable_ccd/#bibtex","title":"BibTex","text":"<pre><code>@misc{Belgrod:2023:Time,\ntitle        = {Time of Impact Dataset for Continuous Collision Detection and a Scalable Conservative Algorithm},\nauthor       = {David Belgrod and Bolun Wang and Zachary Ferguson and Xin Zhao and Marco Attene and Daniele Panozzo and Teseo Schneider},\nyear         = 2023,\neprint       = {2112.06300},\narchivePrefix= {arXiv},\nprimaryClass = {cs.GR}\n}\n</code></pre>"},{"location":"scalable_ccd/#acknowledgments","title":"Acknowledgments","text":"<p>We thank the NYU IT High Performance Computing for resources, services, and staff expertise. This work was funded by the NSF CAREER award under Grant No. 1652515, the NSF grants OAC-1835712, OIA-1937043, CHS-1908767, CHS-1901091, NSERC DGECR-2021-00461 and RGPIN 2021-03707, KAUST baseline funding (grant BAS/1/1679-01-01), by EU project DIGITbrain/ProMED (952071).</p>"},{"location":"tight_inclusion/","title":"Tight Inclusion","text":"<p> A Large Scale Benchmark and an Inclusion-Based Algorithm for Continuous Collision Detection Bolun Wang*, Zachary Ferguson*, Teseo Schneider, Xin Jiang, Marco Attene, Daniele Panozzo (*Joint first authors) <p>ACM Transactions on Graphics, 2021 </p>          An overview of the results of our study of different CCD methods run on 60 million queries (both vertex-face and edge-edge). For each method, we show the number of false positives (i.e., the method detects a collision where there is none), the number of false negatives (i.e., the method misses a collision), and the average run time. Each plot reports results in a logarithmic scale. False positives and negatives are computed with respect to the ground truth computed using Mathematica [Wolfram Research Inc. 2020]."},{"location":"tight_inclusion/#paper","title":"Paper","text":"<p> Paper (PDF) Low res (PDF) <p></p>"},{"location":"tight_inclusion/#abstract","title":"Abstract","text":"<p>We introduce a large-scale benchmark for continuous collision detection (CCD) algorithms, composed of queries manually constructed to highlight challenging degenerate cases and automatically generated using existing simulators to cover common cases. We use the benchmark to evaluate the accuracy, correctness, and efficiency of state-of-the-art continuous collision detection algorithms, both with and without minimal separation.</p> <p>We discover that, despite the widespread use of CCD algorithms, existing algorithms are either: (1) correct but impractically slow, (2) efficient but incorrect, introducing false negatives which will lead to interpenetration, or (3) correct but over conservative, reporting a large number of false positives which might lead to inaccuracies when integrated into a simulator.</p> <p>By combining the seminal interval root-finding algorithm introduced by Snyder in 1992 with modern predicate design techniques, we propose a simple and efficient CCD algorithm. This algorithm is competitive with state-of-the-art methods in terms of runtime while conservatively reporting the time of impact and allowing an explicit trade-off between runtime efficiency and the number of false positives reported.</p>"},{"location":"tight_inclusion/#fast-forward","title":"Fast Forward","text":""},{"location":"tight_inclusion/#presentation","title":"Presentation","text":""},{"location":"tight_inclusion/#video","title":"Video","text":"Your browser does not support the video tag.               Inaccurate collision detection can lead to unnatural \"sticking\" and eventual failure when integrated into simulators (show here using IPC [Li et al. 2020]) because part of the geometry gets stuck inside. Here we show a false negative reported by the Root-Parity method of Brochu et al. [2012] causes the ball to get stuck inside the rollers. Our conservative CCD never misses collisions and so the ball can pass through the rollers without problems."},{"location":"tight_inclusion/#source-code-and-data","title":"Source Code and Data","text":"<ul> <li>GitHub Organization</li> <li>Wrapper and Benchmark</li> <li>Tight-Inclusion (Novel Inclusion-Based CCD)</li> <li>Symbolic CCD</li> <li>Queries:<ul> <li>Sample</li> <li>Full Dataset</li> </ul> </li> </ul>"},{"location":"tight_inclusion/#bibtex","title":"BibTex","text":"<pre><code>@article{Wang:2021:Benchmark,\ntitle        = {A Large Scale Benchmark and an Inclusion-Based Algorithm for Continuous Collision Detection},\nauthor       = {Bolun Wang and Zachary Ferguson and Teseo Schneider and Xin Jiang and Marco Attene and Daniele Panozzo},\nyear         = 2021,\nmonth        = oct,\njournal      = {ACM Transactions on Graphics},\nvolume       = 40,\nnumber       = 5,\narticleno    = 188,\nnumpages     = 16\n}\n</code></pre>"},{"location":"tight_inclusion/#acknowledgments","title":"Acknowledgments","text":"<p>We thank the NYU IT High Performance Computing for resources, services, and staff expertise. This work was partially supported by the NSF CAREER award under Grant No. 1652515, the NSF grants OAC-1835712, OIA-1937043, CHS-1908767, CHS-1901091, National Key Research and Development Program of China No. 2020YFA0713700, EU ERC Advanced Grant CHANGE No. 694515, a Sloan Fellowship, a gift from Adobe Research, a gift from nTopology, and a gift from Advanced Micro Devices, Inc.</p>"}]}